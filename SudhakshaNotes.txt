Module 1: Introduction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
https://www.youtube.com/watch?v=BjNhGaZDr0Y
https://github.com/vilasvarghese/SpringMvcStepByStep
	Spring MVC Primer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://medium.com/thecodefountain/spring-mvc-primer-introduction-to-spring-mvc-c3178e39e715



Define
	IOC and DI
		My solution
	Setter and Constructor injection
		https://www.youtube.com/watch?v=F0oK42CwCuo&list=PL3NrzZBjk6m-nYX072dSaGfyCJ59Q5TEi&index=3
	Autowiring in spring
		https://www.youtube.com/watch?v=aULu-QRagXI&list=PL3NrzZBjk6m-nYX072dSaGfyCJ59Q5TEi&index=6



Model View Controller (usually known as MVC) 
	software design pattern 
	architecture
	framework
	commonly used for developing user interfaces 
	divides the related program logic into three interconnected yet isolated elements. 
	Separate internal representations of information from 
		ways information is presented 
		to and accepted from the user.



	Segregates an application into three components — 
		Model, 
		View, and 
		Controller. 
	Each of these components is assigned with a defined responsibility. 
	
	Model 
		manages the application data 
		decouples the data from its representations (views). 
		
	view 
		presentation of the model data. 
		Can be a UI component (JSP/HTML page)
			an XML or 
			PDF document, 
			JSON data or an 
			RSS or 
			Atom feed. 
	
	Controller 
		accepts input and 
		converts it to the command for model or view.

	Spring WebMVC 
		commonly knows as Spring MVC 
		
		implementation of this MVC design pattern 
		build on top of Servlet API 
		integrated with Spring framework.





	What is a Servlet? What is a jsp?



	Spring MVC Architecture and Components
	--------------------------------------
	Problems in Enterprise Application development with Servlet and JSP Technology:
		Servlet and code are not reusable
		Web designing tools can’t be used in the case of the servlet.
		Parallel development is not possible


	Solution:
		Model 1 (page-centric model) and
		Model 2 (MVC)


	Model 1 - Page Centric Model
	----------------------------
	The request is sent by the browser and received by JSP

	Request -> jsp page [not to a servlet] 
		Either jsp page directly fires query
		or calls a class which processes and returns a list or model like object.

	Page Centric Model - Workflow

	Disadvantages of Page Centric Model include:
		No clear separation of responsibilities
		JSP acts as both controller and view
		The business logic may be separated using Java Bean


	Model 2 - Spring MVC Model
	--------------------------
	Request -> servlet = controller
	servlet can actually connect to the model Java Bean
		which may map to the data source using ORM like hibernate.


	Spring MVC Model - Workflow
	---------------------------
	Requests -> Controller or Servlet receives  from the browser and captures the input
	Controller invokes the business method of java bean
	Java bean connects with the database and gets business data
		The model is formed in the controller.
	Bean sends the response to the controller 
		(keeps the process data in heap memory request, session, and Servlet context)
	Controllers switch the control to appropriate view of the application
		passes the Controller


	Advantages Spring MVC Model
		Clear separation of responsibilities
		Code reusability
		Single point entry for the application
		Support for multiple view technologies



	
	Front Controller Design Pattern
	-------------------------------
	What is the Front Controller Design pattern

	Refer diagram in https://medium.com/thecodefountain/spring-mvc-primer-introduction-to-spring-mvc-c3178e39e715

	Front Controller 
		standard design pattern where a single controller (Servlet in our context) 
			is responsible for handling all request processing. 
		The actual processing is done by different other configurable delegated components.

	Refer diagram above 
	All requests to the application are attended by the Front Controller. 
	The request is then delegated to a controller
		returns a model containing the data to be rendered. 
		The model is then provided to the view template for rendering. 
		Finally, the Front Controller sents out the response to the caller.

	
	Dispatcher Servlet
	------------------
	DispatcherSevlet 
		(It's a standard Java Servlet) 
		front controller in Spring MVC. 
		Can be configured by means of a 
			web.xml
			ServletContainerInitializer or through 
			Spring's AbstractAnnotationConfigDispatcherServletInitializer

	Actors of Spring MVC
	--------------------
	User: 
		Application user/API
	Front Controller: 
		Spring DispatcherServlet 
		Responsible for accepting the request from users 
		delegate and orchestrates the request with other internal components for processing
		
	Handler Mapper: 
		Responsible to find the appropriate controller that can serve the incoming request
	Controller: 
		Processes the request. 
		It invokes the underlying business and repository services. 
		It warps the response data in a model
	View Resolver: 
		Responsible to find the appropriate view which can handle the request
	View: 
		The component on which the processed data (the model returned by the controller) is rendered


	Communication between components in Spring MVC
	----------------------------------------------
	Refer 2nd image in https://medium.com/thecodefountain/spring-mvc-primer-introduction-to-spring-mvc-c3178e39e715
	
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring MVC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The Spring Web model-view-controller (MVC) framework 
	designed around a DispatcherServlet 
		dispatches requests to handlers
			with configurable handler mappings
			view resolution
			locale and
			theme resolution as well as support for uploading files. 
	
	default handler 
		based on the @Controller and @RequestMapping annotations
		offering a wide range of flexible handling methods. 
		With the introduction of Spring 3.0
			@Controller mechanism also allows you to create 
				RESTful Web sites 
				and applications
					through the @PathVariable annotation and other features.

“Open for extension...”
-----------------------
A key design principle in Spring Web MVC [and in Spring in general] 
	"The Open-Closed Principle" http://www.objectmentor.com/resources/articles/ocp.pdf
		“Open for extension
		closed for modification” principle.

Some methods in the core classes of Spring Web MVC are marked final. 
Developer you cannot override these methods 
	These are carefully implemented with above principle in mind.



In Spring Web MVC 
	we can use any object/class as a 
		command or 
		form-backing object; 
	No need to implement a framework-specific interface or base class. 
	Spring's data binding is highly flexible: 
		for example, 
			Treats type mismatches as validation errors 
			Can be evaluated by the application
				not as system errors. 
		
		
	Spring's view resolution is extremely flexible. 
	Controller 
		responsible for 
			preparing a model 
			Map with data 
			selecting a view name 
			write directly to the response stream 
			and complete the request. 
		View name resolution is highly configurable through 
			file extension or 
			Accept header content type negotiation, 
			through 
				bean names
				a properties file
				or even a custom ViewResolver implementation. 
	The model (the M in MVC)
		Map interface
		allows for the complete abstraction of the view technology. 
		Can integrate directly with technologies like 
			JSP, 
			Velocity 
			Freemarker
		or directly generate 
			XML, 
			JSON, 
			Atom
			and many other types of content. 
			

Features of Spring Web MVC
--------------------------
https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-features

	Clear separation of roles. 
		Each role — 
			controller, 
			validator, 
			command object
			form object
			model object
			DispatcherServlet
			handler mapping
			view resolver
				can be fulfilled by a specialized object.

	Configuration of both framework and application classes as JavaBeans. 
		Configuration capability 
			easy referencing across contexts
				such as from web controllers to business objects and validators.

	Adaptability, non-intrusiveness, and flexibility. 
		Define any controller method signature you need
			possibly using one of the parameter annotations (such as @RequestParam, @RequestHeader, @PathVariable, and more) for a given scenario.

	Reusable business code
		No need for duplication. 
		Use existing business objects as 
			command or 
			form objects 
				instead of mirroring them to extend a particular framework base class.

	Customizable binding and validation. 
		Type mismatches as application-level validation errors that 
			keep the offending value, 
			localized date and 
			number binding etc 
		instead of String-only form objects with manual parsing and conversion to business objects.

	Customizable handler mapping and view resolution. 
		Handler mapping and view resolution strategies range from simple URL-based configuration, to sophisticated, purpose-built resolution strategies. Spring is more flexible than web MVC frameworks that mandate a particular technique.

	Flexible model transfer. 
		Model transfer with a name/value Map 
		supports easy integration with any view technology.

	Customizable locale and theme resolution, support for JSPs 
		with or without Spring tag library
		support for JSTL
		support for Velocity 
			without the need for extra bridges, and so on.

	A simple yet powerful JSP tag library [called Spring tag library] 
		provides support for features such as data binding and themes. 
		The custom tags allow for maximum flexibility in terms of markup code. 

	A JSP form tag library
		introduced in Spring 2.0
		makes writing forms in JSP pages much easier. 
		
	Beans whose lifecycle is scoped to the current HTTP request or HTTP Session. 
		Feature of the WebApplicationContext container(s) that Spring MVC uses. 
			
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring Web Modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Refer my slides for Spring Core modules
	
	Spring MVC modules
	------------------
	
	Web
		The web context module 
		Built on top of the application context module 
		Provide context for web-based applications
		The Web module also simplifies the work of processing 
			multi-part requests and 
			binding request parameters to domain objects. 
		The web layer includes 
			Web, 
			Web-Servlet, 
			Web-Struts 
			Web Porlet modules

	Web module (spring-web.jar): 
		Provides basic Web-oriented integration featurese.g. 
			multi-file upload
			using Servlet listeners to initialize the IoC container
			Web-oriented application context. 
			It also contains the relevant parts of the Web in Spring remote support
	Core jar
		spring-beans.jar
		spring-context.jar
		spring-core.jar
		spring-expression.jar

	Other jar's part of the basic framework	
		spring-aop.jar
			Aspect oriented programming
		spring-jcl.jar
			 mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL)
		spring-webmvc.jar
			mvc - especially servlets - e.g. DispatchServlet
	
	Other web based modules.
	------------------------	
	Web-Servlet module web.servlet.jar: 
		This module contains Spring's model-view-controller (MVC) implementation. 
		Spring's MVC framework makes it possible to 
			clearly separate the code within the model range and web forms
			compatible with Spring The other features of the framework are based together
	Web-Struts module: 
		Provides support for Struts
		classes can be integrated with a typical Struts Web layer in Spring applications
	Web-Porlet module: 
		Provides the implementation of MVC for Portlet environment and Web-Servlet module


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring MVC Components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Spring MVC - Components
-----------------------
	DispatcherServlet (org.springframework.web.servlet )
	HandlerMapping (org.springframework.web.servlet)
	Controller
	ModeAndView (org.springframework.web.servlet)
	ViewResolver


DispatcherServlet (org.springframework.web.servlet )
	Already covered

HandlerMapping (org.springframework.web.servlet)
--------------
	HandlerMapping: an interface 
	Implemented by objects to define the mapping between 
		request 
		handler objects. 
	When a request is made to Spring’s dispatcher servlet
		it hands over the request to handler mapping.

	Handler mapping 
		inspects the request, 
		identifies the appropriate handler execution chain
			and delivers it to DispatcherServlet.

	Example:
	Handler mapping provided by Spring’s MVC module can be implemented in many ways.

	BeanNameUrlHandlerMapping: 
		Default handler mapping class 
		maps the URL request to the names of the beans.

	<bean…>
		<bean class=“org.springframework.web.servlet.handler.
		BeanNameUrlHandlerMapping”/>
		<bean name=“/welcome.htm” class=“WelcomeController”/>
		<bean name=“/streetName.htm” class=“StreetNameController”/>
		<bean name=“/process*.htm” class=“ProcessController”/>

	If URL pattern:
		/welcome.htm is requested; 
			DispatcherServlet will forward the request to the “WelcomeController”
		/streetname.htm is requested; 
			DispatcherServlet will forward the request to the “StreetNameController”
		/process(anything).htm is requested; 
			DispatcherServlet will forward the request to the “ProcessController”



Controller
----------
	Components called by the Dispatcher Servlet for any kind of Business logic. 
	All controllers implement the Controller interface.

	The types of controllers are:
		Abstract Controller
		MultiAction Controller
		AbstractWizardFormController


ModeAndView (org.springframework.web.servlet)
--------------------------------------------------
	ModelAndView 
		Represented by class.org.springframework.web.servlet.ModelAndView 
		Returned by the Controller object back to the DispatcherServlet.

	A container class 
		hold the the information of 
			model and 
			view. 
	Model object represents some piece of information 
		can be used by the View to display the information.

	These give abstraction in the Spring framework. 
	Any kind of View Technology (org.springframework.web.servlet.View) 
		can be plugged into the framework. View can be
			Excel, 
			Jasper Reports, 
			Pdf, 
			Xslt, 
			freeMarker, 
			Html, 
			Tiles are supported frameworks.

	Example:

	ModelAndView mv=new ModelAndView(“successView”, “greetingMsg”, “greetingMessage);

ViewResolver
-------------
	ViewResolver 
		An interface 
		Implemented by objects to resolve views using name.
	To resolve view object, 
		DispatcherServlet uses ViewResolver.
	Provide a mapping between 
		Logical View Name and the actual Physical Location of the View Resource.

	Types of ViewResolver
		BeanNameViewResolver
			Resolves the logical name of the view to the bean name
			Bean will render the output to the user. 
			The bean should be defined in the Spring app context file.

		InternalResourceViewResolver
			Resolves the logical name of the view to an internal resource 
				by prefixing the logical view name 
				with the resource path and 
				suffixing it with the extension.


		XMLFileViewResolver
			Similar to BeanNameViewResolver. 
			Difference: instead of looking for the beans in Spring’s application context 
				looks for beans defined in a separate XML file.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	web.xml
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

welcome-file-list in web.xml
	The welcome-file-list element of web-app, is used to define a list of welcome files. Its sub element is welcome-file that is used to define the welcome file.

	A welcome file is the file that is invoked automatically by the server, if you don't specify any file name.

	By default server looks for the welcome file in following order
	
	welcome-file-list in web.xml
		index.html
		index.htm
		index.jsp
		If none of these files are found, server renders 404 error.

	If you have specified welcome-file in web.xml, and all the files index.html, index.htm and index.jsp exists, priority goes to welcome-file.

	If welcome-file-list entry doesn't exist in web.xml file, priority goes to index.html file then index.htm and at last index.jsp file.


	Further reference:
	https://cloud.google.com/appengine/docs/standard/java/config/webxml

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	The DispatcherServlet
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Refer to the image in 
https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-servlet


Spring's web MVC framework 
	request-driven, 
	designed around a central Servlet 
	dispatches requests to controllers 
	offers other functionality that facilitates the development of web applications. 
	
	What else does Spring's DispatcherServlet do
	Completely integrated with the Spring IoC container 
		gives access to features that Spring support.

	Refer the diagram : 
		Request processing workflow of the Spring Web MVC DispatcherServlet. 
		DispatcherServlet is an expression of the “Front Controller” design pattern 
			

The DispatcherServlet 
	Servlet 
	Inherits from the HttpServlet
	Declared in the web.xml of your web application. 
	You need to map requests that you want the DispatcherServlet to handle
	by using a URL mapping in the same web.xml file. 
	This is standard Java EE Servlet configuration; 
	
Example shows such a DispatcherServlet declaration and mapping:

<web-app>
    <servlet>
        <servlet-name>example</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>example</servlet-name>
        <url-pattern>/example/*</url-pattern>
    </servlet-mapping>
</web-app>



all requests starting with /example 
	will be handled by the DispatcherServlet instance named "example". 
	In a Servlet 3.0+ environment
		we can configure the Servlet container programmatically. 
		
-----------------------------------------------
public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet());
        registration.setLoadOnStartup(1);
        registration.addMapping("/example/*");
    }

}
----------------------------------------------------		

WebApplicationInitializer 
	interface provided by Spring MVC 
	Ensures code-based configuration is detected 
		and automatically used to initialize 
		any Servlet 3 container. 
	An abstract base class implementation of this interface named AbstractDispatcherServletInitializer makes it easier to register the DispatcherServlet 
		by simply specifying its servlet mapping. 

Below is the first step.
---------------------------------------------------------------
import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }

}
-----------------------------------------------------------------


The above is only the first step in setting up Spring Web MVC. 
You now need to configure the various beans used by the Spring Web MVC framework (over and above the DispatcherServlet itself).

As detailed in Section 5.14, “Additional Capabilities of the ApplicationContext”, ApplicationContext instances in Spring can be scoped. In the Web MVC framework, each DispatcherServlet has its own WebApplicationContext, which inherits all the beans already defined in the root WebApplicationContext. These inherited beans can be overridden in the servlet-specific scope, and you can define new scope-specific beans local to a given Servlet instance.


		


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring MVC Annotated Controllers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Current trend favor annotations over XML files 
	To facilitate this Spring since 2.5 
		provide support for configuring the MVC framework components using annotations.

	Spring 2.5 
		introduces an annotation-based programming model for MVC controllers
		using annotations like 
			@RequestMapping, 
			@RequestParam
			@ModelAttribute, etc. 
	This annotation support is available for both Servlet MVC and Portlet MVC. 
	Controllers implemented in this style 
		do not have to extend specific base classes 
		implement specific interfaces. 
	Furthermore
		No direct dependencies on Servlet or Portlet API's, although they can easily get access to Servlet or Portlet facilities if desired.




Setting up the dispatcher for annotation support
------------------------------------------------
@RequestMapping 
	By default in both DispatcherServlet and DispatcherPortlet
	@RequestMapping will only be processed if a corresponding 
		HandlerMapping (for type level annotations) and/or 
		HandlerAdapter (for method level annotations) 
		is present in the dispatcher.
	
	.

However, if you are defining custom HandlerMappings or HandlerAdapters, then you need to make sure that a corresponding custom DefaultAnnotationHandlerMapping and/or AnnotationMethodHandlerAdapter is defined as well - provided that you intend to use @RequestMapping.

----------------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

    <bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"/>

    <bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/>

    // ... (controller bean definitions) ...

</beans>
----------------------------------------------------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	@RequestMapping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	@RequestMapping annotation 
		used to map URLs like '/login.do' onto an 
			entire class 
			or a particular handler method. 
		Typically the type-level annotation maps 
			a specific request path (or path pattern) 
			onto a form controller
		with additional method-level annotations 
			'narrowing' the primary mapping for a 
			specific HTTP method request 
			to method ("GET"/"POST") or specific HTTP request parameters.


Further reads: https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch16s11.html


Continue................

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Controller Handler Method Parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s03.html
	
	Controllers provide access to the application behavior 
		define through a service interface. 
	Controllers 
		interpret user input 
		transform it into a model 
			represented to the user by the view. 
	
	Spring 2.5 introduced an annotation-based programming model for MVC controllers 
	It uses annotations such as 
		@RequestMapping, 
		@RequestParam, 
		@ModelAttribute
			etc. 
			
	Defining a controller with @Controller
	--------------------------------------
	@Controller annotation 
		indicates the class which serves the role of a controller. 
		No need to extend any 
			controller base class 
			reference the Servlet API. 
	Can still reference Servlet-specific features if you need to do so.
	The dispatcher scans such annotated classes for mapped methods and detects @RequestMapping annotations (see the next section).

	Define annotated controller beans explicitly
		using a standard Spring bean definition in the dispatcher's context. 
	However, the @Controller stereotype also allows for autodetection, aligned with Spring general support for detecting component classes in the classpath and auto-registering bean definitions for them.

	To enable autodetection of such annotated controllers, you add component scanning to your configuration. Use the spring-context schema as shown in the following XML snippet:

------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p" 
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-3.0.xsd">

    <context:component-scan base-package="org.springframework.samples.petclinic.web"/>

    // ...

</beans>
-----------------------------------------


Mapping requests with @RequestMapping
-------------------------------------
	@RequestMapping annotation 
		map URLs such as /appointments onto 
			an entire class 
			or a particular handler method. 
	You can use it to annotate both a class and a method. 
	Typically the class-level annotation maps a specific request path (or path pattern) onto a form controller, with additional method-level annotations narrowing the primary mapping for a specific HTTP method request method ("GET"/"POST") or specific HTTP request parameters.

For e.g.
---------------------------------------------------------
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {

    private AppointmentBook appointmentBook;
    
    @Autowired
    public AppointmentsController(AppointmentBook appointmentBook) {
        this.appointmentBook = appointmentBook;
    }

    @RequestMapping(method = RequestMethod.GET)
    public Appointments get() {
        return appointmentBook.getAppointmentsForToday();
    }

    @RequestMapping(value="/{day}", method = RequestMethod.GET)
    public void getForDay(@PathVariable Date day, ExternalContext context) {
        Appointments appts = appointmentBook.getAppointmentsForDay(day);
        context.getModel().addAttribute(appts);
        context.selectView("appointments");
        if (context.isAjaxRequest()) {
            //could activate a ViewHelper for component associated with main
            context.renderFragment("main");
        }
    }

    @RequestMapping(value="/new", method = RequestMethod.GET)
    public AppointmentForm getNewForm() {
        return new AppointmentForm();
    }

    @RequestMapping(method = RequestMethod.POST)
    public String post(AppointmentForm form) {
        appointmentBook.createAppointment(form);
        return "redirect:/appointments";
    }
}
---------------------------------------------------------

Supported handler method arguments
----------------------------------
Handler methods annotated with @RequestMapping can have flexible signatures. 

Arguments can be of types, in arbitrary order. 
	(except for validation results, which need to follow right after the corresponding command object, if desired):

Request and/or response objects (Servlet API). 
	Choose any specific request/response type, 
	for example, 
		ServletRequest 
		HttpServletRequest.

Session object (Servlet API): 
	type HttpSession. 
	An argument of this type enforces the presence of a corresponding session. 
	This argument can never be null.
	Session access may not be thread-safe
		in particular in a Servlet environment: 
		Consider switching the 
			AnnotationMethodHandlerAdapter's "synchronizeOnSession" flag to "true" 
				if multiple requests are allowed to access a session concurrently.

org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. 
	Allows for 
		generic request parameter access 
		request/session attribute access
			without ties to the native Servlet/Portlet API.

java.util.Locale for the current request locale
	determined by the most specific locale resolver available
		in effect, the configured LocaleResolver in a Servlet environment.

java.io.InputStream / java.io.Reader 
	to access to the request's content. 
	This value is the raw InputStream/Reader as exposed by the Servlet API.

java.io.OutputStream / java.io.Writer 
	to generate the response's content. 
	This value is the raw OutputStream/Writer as exposed by the Servlet API.

@PathVariabe annotated parameters 
	for access to URI template variables. 
	Refer  “URI Templates” in the same document.

@RequestParam annotated parameters 
	for access to specific Servlet request parameters. 
	Parameter values are converted to the declared method argument type. 
		See Section 15.3.2.4, “Binding request parameters to method parameters with @RequestParam”.

@RequestHeader annotated parameters 
	for access to specific Servlet request HTTP headers. 
	Parameter values are converted to the declared method argument type.

@RequestBody annotated parameters 
	for access to the request HTTP body. 
	Parameter values are converted to the declared method argument type using HttpMessageConverters. 
	See Section 15.3.2.5, “Mapping the request body with the @RequestBody annotation”.

java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap 
	for enriching the implicit model that is exposed to the web view.

Command or form objects to bind parameters to: 
	as bean properties or fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on AnnotationMethodHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default., using the non-qualified command class name in property notation. For example, "orderAddress" for type "mypackage.OrderAddress". Specify a parameter-level ModelAttribute annotation for declaring a specific model attribute name.

org.springframework.validation.Errors / org.springframework.validation.BindingResult validation results 
	for a preceding command or form object 
	(the immediately preceding argument).

org.springframework.web.bind.support.SessionStatus status handle 
	for marking form processing as complete, 
	triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Controller Handler Method Return Types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://docs.spring.io/spring-framework/docs/3.0.0.M4/spring-framework-reference/html/ch15s03.html
	https://www.codejava.net/frameworks/spring/14-tips-for-writing-spring-mvc-controller
	https://www.baeldung.com/spring-mvc-model-model-map-model-view
	
	Supported handler method arguments and return types
	---------------------------------------------------
A ModelAndView object
	model implicitly enriched with command objects 
	and the results of @ModelAttribute annotated reference data accessor methods.
		Refer: https://www.baeldung.com/spring-mvc-and-the-modelattribute-annotation

A Model object
	the view name implicitly determined through a RequestToViewNameTranslator 
	and the model implicitly enriched with command objects 
	and the results of @ModelAttribute annotated reference data accessor methods.

A Map object 
	for exposing a model
	with the view name implicitly determined through a RequestToViewNameTranslator 
	and the model implicitly enriched with command objects 
	and the results of @ModelAttribute annotated reference data accessor methods.

A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).

A String value that is interpreted as the view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).

void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the view name is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).

If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See Section 15.3.2.6, “Mapping the response body with the @ResponseBody annotation”.

Any other return type is considered as single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	View Resolution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch16s05.html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 2: Spring Boot
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	What is Spring Boot?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Spring Boot provides 
a platform for Java developers 
	to develop 
		stand-alone 
		production-grade 
			spring application 
Get started with minimum configurations 
	without the need for an entire Spring configuration setup.
	highly opionated.

Advantages
-------------
	Easy to understand and develop spring applications
	Increases productivity
	Reduces the boot up and development time
	
Goals
------
	To avoid complex XML/jar/etc. configuration in Spring
	To develop a production ready Spring applications in a easier way
	To reduce the development time and run the application independently
	Offer an easier way of getting started with the application

Why Spring Boot?
------------------
Flexible way to configure 
	Java Beans, 
	XML configurations
	Database Transactions.
Powerful 
	batch processing 
	manages REST endpoints.
Everything is auto configured; 
	no manual configurations are needed.
Annotation-based spring application
Eases dependency management
Includes Embedded Servlet Container


How does it work?
-----------------
Automatically configures your application 
	based on the dependencies you have added 
		to the project by using @EnableAutoConfiguration annotation. 
For example, 
	if MySQL database is on your classpath
	and we have not configured any database connection
	then Spring Boot auto-configures an in-memory database.

Entry point of the spring boot application: 
	Class with 
		@SpringBootApplication annotation 
		and the main method.

Automatically scans all the components included in the current folder and all sub folder.

Spring Boot Starters
--------------------
Handle dependency management
	For example, if you want to use Spring and JPA for database access, it is sufficient if you include spring-boot-starter-data-jpa dependency in your project.

Note that all Spring Boot starters follow the same naming pattern spring-boot-starter- *, where * indicates that it is a type of the application.

Examples
Look at the following Spring Boot starters explained below for a better understanding −

Spring Boot Starter Actuator dependency is used to monitor and manage your application. Its code is shown below −

Starter project code base: https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring Boot Main Features
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Features	
	AutoConfiguration
		Detects the presence of certain a Class in the Classpath and then automatically configures it for you.
			e.g. H2 db
		Saves a lot of work 
		Reduce the development time 
		
	Starter POMs
		To build a simple Spring MVC-based REST application that supports Jackson 
			and to run it an embedded container
			you would at least need the following dependencies:

		spring-core.jar
		spring-web.jar
		spring-webmvc.jar
		jackson-databind.jar
		tomcat-embed-core.jar
		tomcat-embed-el.jar
		tomcat-embed-logging-juil.jar

		Get all these by adding 
			spring-boot-starter-web dependency in your pom.xml
			
	Spring Boot CLI
		command line interface provided by the Spring Boot framework
		Spring Boot CLI detect that @RestController and @RequestMapping are in use, and it knows which starter dependencies are required to add into classpath to make it work.
		
	Actuator
		Actuator is another awesome feature of Spring Boot that allows seeing what's going on inside a running Spring Boot application. 
		
		
	Spring Boot Initializer
		Spring Initializer project can be accessed at https://start.spring.io/
		download the Zip file and then open into an IDE like Eclipse or IntelliJ IDEA
		
Reference:https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html
	SpringApplication
		SpringApplication class 
			provides a convenient way to bootstrap a Spring application 
				started from a main() method. 
	
	 Startup Failure
		If your application fails to start, registered FailureAnalyzers get a chance to provide a dedicated error message and a concrete action to fix the problem.
		if you start a web application on port 8080, we get a clear error message.
		
	Lazy Initialization
		SpringApplication allows an application to be initialized lazily. When lazy initialization is enabled, beans are created as they are needed rather than during application startup.
		Enabling lazy initialization can reduce the time that it takes your application to start. 
		Set the following property to true
		spring.main.lazy-initialization=true
				
	Customizing the Banner
		banner that is printed on start up can be changed by adding a banner.txt file to your classpath or by setting the spring.banner.location property to the location of such a file
		
		Refer: https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html for a list of properties that can be set.
		
	Customizing SpringApplication
		If the SpringApplication defaults are not to your taste
			instead create a local instance and customize it.
			e.g.
--------------------------------
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}
--------------------------------

	Fluent Builder API
		If you need to build an ApplicationContext hierarchy (multiple contexts with a parent/child relationship) or if you prefer using a “fluent” builder API, you can use the SpringApplicationBuilder.
		SpringApplicationBuilder lets you chain together multiple method calls and includes parent and child methods that let you create a hierarchy,
--------------------------------
new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
--------------------------------
		
	Application Availability
		applications can provide information about their availability to the platform using infrastructure such as Kubernetes Probes. 
		Spring Boot includes out-of-the box support for the commonly used “liveness” and “readiness” availability states. 
		
		Liveness State
			 “Liveness” state of an application tells whether its internal state allows it to work correctly, or recover by itself if it’s currently failing. 
			 like 15 people talking to a person.
			 Without doing anything to the person, if 14 stop speaking, s/he will understand
			broken “Liveness” state 
				application is in a state that it cannot recover from
				the infrastructure should restart the application.

			Internal state of Spring Boot applications is mostly represented by the Spring ApplicationContext
			If the application context has started successfully, Spring Boot assumes that the application is in a valid state. An application is considered live as soon as the context has been refreshed

		Readiness State
			“Readiness” state 
				application is ready to handle traffic. 
				While you in the class, you fell asleep/sick.
				Now either you have to wake up or you have take medicine.
				
				A failing “Readiness” state tells the platform 
					don't route traffic to the application for now. 
					Typically happens during startup
						while CommandLineRunner and ApplicationRunner components are being processed
						or at any time if the application decides that it’s too busy for additional traffic.

	Many more features
		Kindly read https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html


	Makes web dev. easy
	Makes RESTful service dev. easy
	Application Events and Listeners
		Spring Boot uses events to handle variety of tasks. 
		Allows us to create factories file that are used to add listeners. 
		we can refer it by using ApplicationListener key.
			META-INF/spring.factories
	Admin Support
		Spring Boot provides the facility to enable admin related features for the application. It is used to access and manage application remotely. We can enable it by simply using spring.application.admin.enabled property.
		
	Externalized Configuration
		Properties Files
		Drive from CLI
		Property server
	YAML support
	Type-safe Configuration
		Provided to govern and validate the configuration of application.
	Logging
		Spring Boot uses Common logging for all internal logging. Logging dependencies are managed by default
	Security
		Pluggable security.
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Using Spring CLI
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Install
		https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-installing-the-cli
	Use Spring	
		https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html
	java -jar <your service build>.war / .jar
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Example of Spring MVC-based RESTful Web Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Reference video series:
	https://www.youtube.com/watch?v=4qBvR7BKOTI&list=PLtUIbLoyHO9fUj4abxgdghIfBIezTcvnc&index=3
	https://www.java-success.com/category/java-engineers/0006-spring/02-spring-mvc/
	
	https://www.java-success.com/setting-apache-tomcat-application-server/
	https://www.java-success.com/spring-mvc-beginner-tutorial-step-step/
	https://www.java-success.com/05-spring-4-mvc-restful-web-service-beginner-tutorial-step-step/
	
		N.B: What didn't work for me.
			tomcat7 didn't work.
			So updated the tomcat as tomcat9 using the following plugin
			
---------------------------------------------
                <plugin>
                <groupId>org.codehaus.cargo</groupId>
                <artifactId>cargo-maven2-plugin</artifactId>
                <version>1.8.3</version>
                <configuration>
                    <container>
                        <containerId>tomcat9x</containerId>
                        <type>embedded</type>
                    </container>
                    <deployables>
                        <deployable>
                            <type>war</type>
                            <location>${project.build.directory}/${project.build.finalName}.war</location>
                            <properties>
                                <context>/</context>
                            </properties>
                        </deployable>
                    </deployables>
                </configuration>
            </plugin>
			
---------------------------------------------
goal in the maven build should be "package cargo:run"
Reference: https://stackoverflow.com/questions/41326911/maven-plugin-for-tomcat-9


	Reference for mvc post: https://www.java-success.com/06-spring-4-mvc-restful-get-post-methods-web-services-tutorial/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring Booting Basic RESTful Web Service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://github.com/vilasvarghese/microservices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring Boot Skeletal Application Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://github.com/vilasvarghese/microservices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Externalized Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Drive changes easily.
		key and value pair.
	Externalized 
	Centralized configuration
	Version management
	
	
	Why configure?
		don't hardcode.
		Properties like db username, connect string etc. can be 
			configured
			required in multiple places.
		
		Feature flags etc..
		Config changes can sometimes directly pushed to production
			Already tested and approved
			
	Config files
		xml
		yaml files
		json
		properties
		
	Microservices
		Lot of microservices: sometimes require configuration.
		
		
	Configuration should be 
		Externalized (property files)
		Environment specific (Spring profiles)
		Consistent (Spring cloud config server)
		Version history (Git repo)
		Real-time management.
		
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Logging
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://www.baeldung.com/spring-boot-logging
	
mvn spring-boot:run -Dspring-boot.run.arguments=--logging.level.org.springframework=TRACE -Dspring-boot.run.arguments=--logging.level.com.hsbg.logging=TRACE


	https://springframework.guru/using-logback-spring-boot/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 3: Microservices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	My personal notes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	What are Microservices?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Decentralized Governance, Scalability, Fault Tolerance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Decentralized Governance
		Property files
		Centralized config server
		
		
		
	Issues possible
		Instance can go down
			Soln: Create multiple instances of the microservices.
			Eureka
		
		Microservice is slow.
		
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Cloud Computing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://github.com/vilasvarghese/aws/blob/master/Notes/AWSTOC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Spring Cloud
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://spring.io/projects/spring-cloud
	
Spring Cloud 
	Tools to quickly build some of the common patterns in distributed systems 
		(e.g. 
		configuration management, 
		service discovery, 
		circuit breakers, 
		intelligent routing, 
		micro-proxy, 
		control bus, 
		one-time tokens, 
		global locks, 
		leadership election, 
		distributed sessions, 
		cluster state). 

Features
Spring Cloud focuses on providing good out of box experience for typical use cases and extensibility mechanism to cover others.

	Distributed/versioned configuration
	Service registration and discovery
	Routing
	Service-to-service calls
	Load balancing
	Circuit Breakers
	Global locks
	Leadership election and cluster state
	Distributed messaging


Adding Spring Cloud To An Existing Spring Boot Application
----------------------------------------------------------
1. Determine the version of Spring Cloud you should use. 
	depend on the version of Spring Boot you are using.

Refer table in https://spring.io/projects/spring-cloud#overview

2. Add the "dependency management" and version to the pom.xml
---------------------------------------------
<properties>
    <spring.cloud-version>2020.02.01</spring.cloud-version>
</properties>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring.cloud-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
---------------------------------------------

3. Identify the dependencies 
	Spring Cloud projects also include starters 
		add them as dependencies to add various cloud native features to your project. 
	Features can be enabled by adding the starter to your classpath. 
	
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Service and Client Discovery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://github.com/vilasvarghese/microservices/blob/master/training/day3/EurekaServiceDiscovery/EurekaInstructions.txt
	https://github.com/vilasvarghese/microservices/blob/master/training/day3/EurekaServiceDiscovery/DependenciesIncaseOfFailures.txt
	

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Netflix OSS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

https://netflix.github.io/

Netflix OSS 
	set of frameworks and libraries wrote by Netflix 
	Solve some common microservices distributed-systems problems at scale. 
	
	for e.g. Patterns for 
		service discovery, 
		load balancing, 
		fault-tolerance, etc are solved by Netflix 
	
	Netflix OSS 
		written when there were no alternatives. 
		
So that brings us to point #1.
	Microservices can be implemented in a variety of frameworks/languages 
	things like (3 most used featuers)
		service discovery, 
		load balancing, 
		fault-tolerance, etc are still quite important. 

	
	
	Client-side load balancing?
		Netflix wrote Eureka and Ribbon 
		Combinations - can enable client-side load balancing. 
		Service registry 
			(Eureka/Consul/Zookeeper/etc) will keep track of services exist in a cluster 
			AND sending that data to clients that are interested in this. Then, since the client has information about what nodes are in the cluster, it can pick one (randomly, sticky, or some custom algorithm) and then call it. On it’s next call, it can pick a different service in the cluster if it so desires. The advantages here are we don’t need physical/soft loadbalancers which could quickly become a bottleneck. Another important aspect: since the client knows where the service is, the client can contact the service provider directly without additional hops.

IMHO client-side load balancing is the 5% use case. Let me explain.

What we want is a way to do scalable load-balancing ideally without any additional appliances and client libraries. In most cases we probably don’t care about the extra hop with a load balancer in the middle (think about it.. probably 99% of your apps are probably deployed this way right now). We could get into a situation where a call to service A calls service B which calls service C, and D, and E, and you get the picture. In this case if each one took an extra hop we’d incur lots of additional latency. So a possible solution could be “remove the extra hops”.. and it is… but not just in the hops to load balancers: in the number of calls you have to make to downstream services :) Follow my blog on event-driven systems and the discussion around Autonomy vs Authority to see where I’m going with that :)

Using Kubernetes Services as we did in the Service Discovery section above, we accomplish proper load balancing (again, without all of the overhead of the service registries, custom clients, DNS drawbacks, etc). When we interact with a Kubernetes Service via its DNS (or IP), Kubernetes will by default load balance across the pods in the cluster (remember, the cluster is defined by the labels and label selectors). If you don’t want the extra hops in the load balancing, no worries; this virtual IP is routed directly to the Pods, it does not hit a physical network

Yay! Easy for the 95% use case. And chances are, you’re in the 95% distribution of use cases, so don’t need to over-engineer things. Keep it simple.

What about that 5% case? You may have a case where you have to make some business decision at runtime about which exact backend endpoint within a cluster you really want to call. Basically you want to use some custom algorithm that’s more complicated than just “round robin”, “random”, “sticky-session” and is specific to your application. Use client-side load balancing for that. In this model, you can still leverage Kubernetes’ service discovery to find out which pods are in the cluster and then use your own code to decide which pod to call directly (based on labels, etc). The Kubeflix project from the fabric8.io community has discovery plugins for using Ribbon, for example, to get a list of all the pods for a service from the Kubernetes REST API and then let users use Java code to make business decisions about which pod to call. The same thing can be done for other languages and just use the Kubernetes REST API to query the pods, etc. For these use-cases it can make sense to invest in client-specific discovery libraries. Even more appropriate is to break this custom logic into its own module so its dependencies are separate from the application. With Kubernetes, you can deploy this separate module as a sidecar to your application/service and keep the custom load balancing logic there.


	
	
	Disadvantages with Netflix oss compared to Orchestrator like k8s
		Most of them will work with java only 
		heavy weight
	

Refer image in 
https://netflixtechblog.com/netflix-oss-and-spring-boot-coming-full-circle-4855947713a0	




@LoadBalanced
Used as a marker annotation indicating that the annotated RestTemplate should use a RibbonLoadBalancerClient for interacting with your service(s).

In turn, this allows you to use "logical identifiers" for the URLs you pass to the RestTemplate. These logical identifiers are typically the name of a service. For example:

restTemplate.getForObject("http://some-service-name/user/{id}", String.class, 1);
where some-service-name is the logical identifier.

@RibbonClient
Used for configuring your Ribbon client(s).

Is @RibbonClient required?

No! If you're using Service Discovery and you're ok with all of the default Ribbon settings, you don't even need to use the @RibbonClient annotation.

When should I use @RibbonClient?

There are at least two cases where you need to use @RibbonClient

You need to customize your Ribbon settings for a particular Ribbon client
You're not using any service discovery
Customizing your Ribbon settings:

Define a @RibbonClient

@RibbonClient(name = "some-service", configuration = SomeServiceConfig.class)
name - set it to the same name of the service you're calling with Ribbon but need additional customizations for how Ribbon interacts with that service.
configuration - set it to an @Configuration class with all of your customizations defined as @Beans. Make sure this class is not picked up by @ComponentScan otherwise it will override the defaults for ALL Ribbon clients.
See the section "Customizing the RibbonClient` in the Spring Cloud Netflix documentation (link)

Using Ribbon without Service Discovery

If you're not using Service Discovery, the name field of the @RibbonClient annotation will be used to prefix your configuration in the application.properties as well as "logical identifier" in the URL you pass to RestTemplate.

Define a @RibbonClient

@RibbonClient(name = "myservice")
then in your application.properties

myservice.ribbon.eureka.enabled=false
myservice.ribbon.listOfServers=http://localhost:5000, http://localhost:5001
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 4: Netflix OSS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Service Discovery
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Eureka Servers and Clients
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Load Balancing with Ribbon using Eureka
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html
https://howtodoinjava.com/spring-cloud/spring-boot-ribbon-eureka/
https://www.baeldung.com/spring-cloud-rest-client-with-netflix-ribbon
https://www.javainuse.com/spring/spring_ribbon
https://www.youtube.com/watch?v=rsrYZ5cEySE

Steps.
1. Add ribbon in classpath/pom.xml
2. Enable DiscoverClient and Disable EurekaClient
3. Disable Loadbalanced for RestTemplate
4. Use LoadBalancerClient to get the instance from Eureka.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Load Balancing with Ribbon without Eureka
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.baeldung.com/spring-cloud-rest-client-with-netflix-ribbon

Ribbon is a client-side load balancer 
Gives a lot of control over the behavior of HTTP and TCP clients. 
Feign already uses Ribbon.

A central concept in Ribbon is that of the named client. 
Each load balancer is part of an ensemble of components that work together to contact a remote server on demand, and the ensemble has a name that you give it as an application developer (for example, by using the @FeignClient annotation). On demand, Spring Cloud creates a new ensemble as an ApplicationContext for each named client by using RibbonClientConfiguration. This contains (amongst other things) an ILoadBalancer, a RestClient, and a ServerListFilter.

To include Ribbon in your project, use the starter with a 
	group ID of org.springframework.cloud and an 
	artifact ID of spring-cloud-starter-netflix-ribbon
	
	
Why use Ribbon	
	https://gvnix.medium.com/load-balancing-by-ribbon-in-spring-boot-8862e4d70ed1
	
https://o7planning.org/11739/undertanding-load-balancing-in-spring-cloud-with-ribbon-and-example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Module 5: Communication between microservices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Introduction to Feign
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

https://www.javainuse.com/spring/spring-cloud-netflix-feign-tutorial


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Configuring Feign
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.javainuse.com/spring/spring-cloud-netflix-feign-tutorial



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 6: Circuit Breakers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	What is bad with retry?
		blocking threads
		
	Fail fast
		open the circuit
	Fallback
	Automatic recovery
	
	
	Answer the following before you solve
		When to break the circuit?
		What to do when the circuit breaks?
		When do you resume?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Circuit Breakers - Hystrix
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.javainuse.com/spring/springcloud
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Access services using Feign REST client
	
	
	Feign allows you to abstract the mechanics of calling a REST service. Once you configure and annotate the Feign interface, you can call a REST service by making a simple Java function call. The actual implementation of making a REST call is handled at runtime by Feign. This means that the implementation can be configured without changing your business logic code.

By just changing the Feign configuration in a Java or using properties you can add encoding/decoding, logging, and change the REST call implementation library. All this is done through configuration only, while the business logic that calls the service remains unchanged. Since Feign uses standard Java interfaces, it's also easy to mock them during unit tests.

1.URLs are not hardcoded.

2.you don't have to write unit test cases for feign as there is no code to test however you have to write integration tests.

3.we can use Eureka Client ID instead of the URL.
	Can be done with RestTemplate

4.Feign handled the actual code.

5.Feign integrates with Ribbon and Eureka Automatically.

6.Feign provides a very easy way to call RESTful services.


Disadvantage with Feign 
	Does not support caching based on Cache Control headers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 7: Sleuth and Zipkin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.javainuse.com/spring/springcloud
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Logging with Sleuth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	https://www.javainuse.com/spring/cloud-sleuth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Monitor with Zipkin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.youtube.com/watch?v=Oxfk3gns5qo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Module 8 : Spring Scheduler and Integration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Introduction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Scheduler - Cron and Delay
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.baeldung.com/spring-scheduled-tasks
https://www.baeldung.com/spring-task-scheduler
https://docs.spring.io/spring-framework/docs/3.1.x/spring-framework-reference/html/scheduling.html
https://howtodoinjava.com/spring-core/spring-scheduled-annotation/
https://docs.spring.io/spring-framework/docs/3.1.x/spring-framework-reference/html/scheduling.html

Reference: my scheduler repo.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	Integration - FTP ,SSH,HTTPS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

FTP
	File transfer protocol
	FTPS
		Secured FTP
	SFTP
		FTP based on SSH.
	Use SFTP as much as possible
	Authenticate using 
		credentials.
		certificates
	
	Reference for SFTP: https://www.youtube.com/watch?v=j0AG4KrzCgs
	
	FTP Reference: https://www.baeldung.com/java-ftp-client
	Another reference: 
	https://github.com/kuljaninemir/spring-boot-ftp-client
	https://spring.io/blog/2020/03/18/spring-tips-remote-file-system-integrations-ftp-with-spring-integration
	
SSH
	https://www.baeldung.com/java-ssh-connection
	https://stackoverflow.com/questions/42107640/send-and-receive-files-from-ftp-in-spring-boot
	
HTTPS:
	https://www.baeldung.com/spring-boot-https-self-signed-certificate
	https://www.thomasvitale.com/https-spring-boot-ssl-certificate/
	https://docs.spring.io/spring-cloud-skipper/docs/1.0.0.BUILD-SNAPSHOT/reference/html/configuration-security-enabling-https.html
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://www.youtube.com/watch?v=RbZvXCAtMus
https://www.springboottutorial.com/
https://www.springboottutorial.com/unit-testing-for-spring-boot-rest-services


Testing
Junit
	https://www.springboottutorial.com/junit-tutorial-for-beginners
Mockito
	https://www.springboottutorial.com/mockito-tutorial-for-beginners
UnitTesting for beginners
	https://www.springboottutorial.com/unit-testing-for-spring-boot-rest-services
	
Official documentation for junit5	
	https://junit.org/junit5/docs/current/user-guide/
	
	
	JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage


JUnit Platform 
	Foundation for launching testing frameworks on the JVM. 
	Also defines TestEngine API 
		develop testing framework that runs on the platform. 
		Platform provides a Console Launcher 
			Launch the platform from the command line and a JUnit 4 based Runner for running any TestEngine on the platform in a JUnit 4 based environment. 
		First-class support for the JUnit Platform also exists in popular IDEs 
			IntelliJ IDEA, 
			Eclipse, 
			NetBeans
			Visual Studio Code
		and 
			build tools 
				Gradle
				Maven
				Ant.
				
JUnit Jupiter 
	Combination of 
		new programming model and 
		extension model 
			for writing tests and extensions in JUnit 5. 
	Provides a TestEngine for running Jupiter based tests on the platform.

JUnit Vintage 
	Provides a TestEngine for running 
		JUnit 3 and 
		JUnit 4 based 
			tests on the platform.

	Supported Java Versions
		JUnit 5 requires Java 8 (or higher) at runtime. However, you can still test code that has been compiled with previous versions of the JDK.

--------------------------------------
import static org.junit.jupiter.api.Assertions.assertEquals;

import example.util.Calculator;
import org.junit.jupiter.api.Test;
class MyFirstJUnitJupiterTests {

    private final Calculator calculator = new Calculator();

    @Test
    void addition() {
        assertEquals(2, calculator.add(1, 1));
    }

}
--------------------------------------


More details: https://junit.org/junit5/docs/current/user-guide/
Assert documentation:
	https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html
AssertJ
	https://assertj.github.io/doc/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Flux
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Priority1
	https://howtodoinjava.com/spring-webflux/spring-webflux-tutorial/

Others
	https://www.educative.io/blog/spring-webflux-tutorial
	
	
	The reactive-stack web framework, Spring WebFlux, 
		added Spring 5.0. 
		Fully non-blocking, 
		Supports reactive streams back pressure
		Runs on such servers like Netty, Undertow, and Servlet 3.1+ containers
		
	1. Reactive Programming
	-----------------------
Reactive programming	
	Programming paradigm 
	Promotes 
		asynchronous, 
		non-blocking, 
		event-driven 
			approach to data processing. 
	Model data and events as observable data streams 
	Implementing data processing routines to react to the changes in those streams.


	1.1. Blocking vs non-blocking (async) request processing
	1.1.1. Blocking request processing
	----------------------------------
In traditional MVC applications
	When a request come to server, a servlet thread is created. 
	It delegates the request to worker threads for 
		I/O operations such as database access etc. 
	While worker threads are busy
		servlet thread (request thread) remain in 
			waiting status and thus it is blocked. 
	It is also called synchronous request processing.
Check the image
	https://howtodoinjava.com/spring-webflux/spring-webflux-tutorial/

As server can have some finite number of request threads
	it limits the server capability to process that number of requests at maximum server load. 
	It may hamper the performance and limit the full utilization of server capability.


	1.1.2. Non-blocking request processing
	--------------------------------------
In non-blocking or asynchronous request processing, 
	no thread is in waiting state. 
	Generally only one request thread is enough receiving the request.

All incoming requests come with a event handler and call back information. 
Request thread delegates the incoming requests to a thread pool 
	(generally small number of threads) 
	which delegate the request to it’s handler function 
	and immediately start processing other incoming requests from request thread.

When the handler function is complete, 
	one of thread from pool collect the response and pass it to the call back function.

Non-blocking nature of threads helps in scaling the performance of the application. Small number of threads means less memory utilization and also less context switching as well.
	
	
	
1.2. What is reactive programming?
The term, “reactive,” refers to programming models that are built around reacting to changes. It is build around publisher-subscriber pattern (observer pattern). In reactive style of programming, we make a request for resource and start performing other things. When the data is available, we get the notification along with data inform of call back function. In callback function, we handle the response as per application/user needs.

One important thing to remember is back pressure. In non-blocking code, it becomes important to control the rate of events so that a fast producer does not overwhelm its destination.

Reactive web programming is great for applications that have streaming data, and clients that consume it and stream it to their users. It is not great for developing traditional CRUD applications. If you’re developing the next Facebook or Twitter with lots of data, a reactive API might be just what you’re looking for.

2. Reactive Streams API
The new Reactive Streams API was created by engineers from Netflix, Pivotal, Lightbend, RedHat, Twitter, and Oracle, among others and is now part of Java 9. It defines four interfaces:

Publisher: Emits a sequence of events to subscribers according to the demand received from its subscribers. A publisher can serve multiple subscribers.
It has a single method:

Publisher.java
public interface Publisher<T> 
{
    public void subscribe(Subscriber<? super T> s);
}
Subscriber: Receives and processes events emitted by a Publisher. Please note that no notifications will be received until Subscription#request(long) is called to signal the demand.
It has four methods to handle various kind of responses received.

Subscriber.java
public interface Subscriber<T> 
{
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
Subscription: Defines a one-to-one relationship between a Publisher and a Subscriber. It can only be used once by a single Subscriber. It is used to both signal desire for data and cancel demand (and allow resource cleanup).
Subscription.java
public interface Subscription<T> 
{
    public void request(long n);
    public void cancel();
}
Processor: Represents a processing stage consisting of both a Subscriber and a Publisher and obeys the contracts of both.
Processor.java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> 
{
}
Two popular implementations of reactive streams are RxJava (https://github.com/ReactiveX/RxJava) and Project Reactor (https://projectreactor.io/).

3. What is Spring WebFlux ?
Spring WebFlux is parallel version of Spring MVC and supports fully non-blocking reactive streams. It support the back pressure concept and uses Netty as inbuilt server to run reactive applications. If you are familiar with Spring MVC programming style, you can easily work on webflux also.

Spring webflux uses project reactor as reactive library. Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. It is developed in close collaboration with Spring.

Spring WebFlux heavily uses two publishers :

Mono: Returns 0 or 1 element.
Mono<String> mono = Mono.just("Alex");
Mono<String> mono = Mono.empty();
Flux: Returns 0…N elements. A Flux can be endless, meaning that it can keep emitting elements forever. Also it can return a sequence of elements and then send a completion notification when it has returned all of its elements.
Flux<String> flux = Flux.just("A", "B", "C");
Flux<String> flux = Flux.fromArray(new String[]{"A", "B", "C"});
Flux<String> flux = Flux.fromIterable(Arrays.asList("A", "B", "C"));
 
//To subscribe call method
 
flux.subscribe();
In Spring WebFlux, we call reactive APIs/functions that return monos and fluxes and your controllers will return monos and fluxes. When you invoke an API that returns a mono or a flux, it will return immediately. The results of the function call will be delivered to you through the mono or flux when they become available.

To build a truly non-blocking application, we must aim to create/use all of its components as non-blocking i.e. client, controller, middle services and even the database. If one of them is blocking the requests, our aim will be defeated.


	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
